<div class="container py-5 page {{template|handleize}}" id="page-content-{{page.handle}}"><div class="row pt-5"><div class="col-12"><div class="row"><div class="col-12"><h1 class="page-title">{{ page.title }}</h1><div class="rte">{{ page.content }}</div><div class="content"><section class="my-5"><h2 id="install">Install</h2><p>You can grab the latest stable release from <a href="https://raw.githubusercontent.com/blikblum/riba/master/dist/riba.js">github</a> or install using the package manager of your choice.</p>
<pre><code class="language-bash">npm install riba
</code></pre>
<p>Use in a script tag...</p>
<pre><code class="language-html">&lt;script src=&quot;riba.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>... or import using a bundler like webpack</p>
<pre><code class="language-javascript">import riba from 'riba'
</code></pre>
</section><section class="my-5"><h2 id="usage">Usage</h2><section class="my-4"><h3 id="templates">Templates</h3><p>Templates describe your UI in plain HTML. You can define them directly in the document, use template elements or store and load them however you like. Just make sure you have a convenient way to reference your templates when you want to bind some data to them.</p>
<pre><code class="language-html">&lt;section id=&quot;auction&quot;&gt;
  &lt;h3&gt;{ auction.product.name }&lt;/h3&gt;
  &lt;p&gt;Current bid: { auction.currentBid | money }&lt;/p&gt;

  &lt;aside rv-if=&quot;auction.timeLeft | lt 120&quot;&gt;
    Hurry up! There is { auction.timeLeft | time } left.
  &lt;/aside&gt;
&lt;/section&gt;
</code></pre>
<p>The important parts to note here are the attributes prefixed with <code>rv-</code> and portions of text wrapped in <code>{ ... }</code>. These are binding declarations and they are the sole way that riba ties data to your templates. The values of these declarations all follow the same minimal and expressive syntax.</p>
<pre><code>(keypath | primitive) [formatters...]
</code></pre>
<p>Keypaths get observed and will recompute the binding when any intermediary key changes. A primitive can be a string, number, boolean, null or undefined.</p>
<p><a href="#formatters">Formatters</a> can be piped to values using <code>|</code> and they follow a similarly minimal yet expressive syntax. <a href="#formatters-arguments">Formatter arguments</a> can be keypaths or primitives. Keypath arguments get observed and will recompute the binding when any intermediary key changes.</p>
<pre><code>(formatter) [keypath | primitive...]
</code></pre>
</section><section class="my-4"><h3 id="binding">Binding</h3><p>Simply call <code>riba.bind</code> on a template element with some data that you would like to bind.</p>
<pre><code class="language-javascript">riba.bind(document.getElementById('auction'), {auction: auction})
</code></pre>
<p><em>Every call to <code>riba.bind</code> returns a fully data-bound view that you should hold on to for later. You'll need it in order to unbind it's listeners using <code>view.unbind()</code>.</em></p>
</section><section class="my-4"><h3 id="configuring">Configuring</h3><p>Use <code>riba.configure</code> to set the following configuration options for your app. Note that all configuration options can be overridden locally to a particular view if needed.</p>
<pre><code class="language-javascript">riba.configure({

  // Attribute prefix in templates
  prefix: 'rv',

  // Preload templates with initial data on bind
  preloadData: true,

  // Root sightglass interface for keypaths
  rootInterface: '.',

  // Template delimiters for text bindings
  templateDelimiters: ['{', '}'],

  // Augment the event handler of the on-* binder
  handler: function(target, event, binding) {
    this.call(target, event, binding.view.models)
  }

})
</code></pre>
</section></section><section class="my-5"><h2 id="binders">Binders</h2><p>Binders are the sets of instructions that tell riba how to update the DOM when an observed property changes. riba.js comes bundled with a handful commonly-used binders for your conveneience. See the <a href="/docs/reference/">Binder Reference</a> to learn more about the built-in binders that are available out of the box.</p>
<p>While you can accomplish most UI tasks with the built-in binders, it is highly encouraged to extend riba with your own binders that are specific to the needs of your application.</p>
<section class="my-4"><h3 id="one-way-binders">One-way Binders</h3><p>One-way binders simply update the DOM when a model property changes (model-to-view only). Let's say we want a simple binder that updates an element's color when the model property changes. Here we can define a one-way <code>color</code> binder as a single function. This function takes the element and the current value of the model property, which we will use to updates the element's color.</p>
<pre><code class="language-javascript">riba.binders.color = function(el, value) {
  el.style.color = value
}
</code></pre>
<p>With the above binder defined, you can now utilize the <code>rv-color</code> declaration in your views.</p>
<pre><code class="language-html">&lt;button rv-color=&quot;label.color&quot;&gt;Apply&lt;/button&gt;
</code></pre>
</section><section class="my-4"><h3 id="two-way-binders">Two-way Binders</h3><p>Two-way binders, like one-way binders, can update the DOM when a model property changes (model-to-view) but can also update the model when the user interacts with the DOM (view-to-model), such as updating a control input, clicking an element or interacting with a third-party widget.</p>
<p>In order to update the model when the user interacts with the DOM, you need to tell riba.js how to bind and unbind to that DOM element to set the value on the model. Instead of defining the binder as a single function, two-way binders are defined as an object containing a few extra functions.</p>
<pre><code class="language-javascript">riba.binders.toggle = {
  bind: function(el) {
    adapter = this.config.adapters[this.key.interface]
    model = this.model
    keypath = this.keypath

    this.callback = function() {
      value = adapter.read(model, keypath)
      adapter.publish(model, keypath, !value)
    }

    $(el).on('click', this.callback)
  },

  unbind: function(el) {
    $(el).off('click', this.callback)
  },

  routine: function(el, value) {
    $(el)[value ? 'addClass' : 'removeClass']('enabled')
  }
}
</code></pre>
</section><section class="my-4"><h3 id="two-way-binders">Two-way Binders</h3><h4>binder.bind</h4>
<p>This function will get called for this binding on the initial <code>view.bind()</code>. Use it to store some initial state on the binding, or to set up any event listeners on the element.</p>
<h4>binder.unbind</h4>
<p>This function will get called for this binding on <code>view.unbind()</code>. Use it to reset any state on the element that would have been changed from the routine getting called, or to unbind any event listeners on the element that you've set up in the <code>binder.bind</code> function.</p>
<h4>binder.routine</h4>
<p>The routine function is called when an observed attribute on the model changes and is used to update the DOM. When defining a one-way binder as a single function, it is actually the routine function that you're defining.</p>
<h4>binder.publishes</h4>
<p>Set this to true if you want view.publish() to call publish on these bindings.</p>
<h4>binder.block</h4>
<p>Blocks the current node and child nodes from being parsed (used for iteration binding as well as the if/unless binders).</p>
</section></section><section class="my-5"><h2 id="formatters">Formatters</h2><p>Formatters are functions that mutate the incoming and/or outgoing value of a binding. You can use them to format dates, numbers, currencies, etc. and because they work in a similar fashion to the Unix pipeline, the output of each feeds directly as input to the next one, so you can stack as many of them together as you like.</p>
<section class="my-4"><h3 id="one-way-formatters">One-way formatters</h3><p>This is by far the most common and practical way to use formatters â€” simple read-only mutations to a value. Taking the dates example from above, we can define a <code>date</code> formatter that returns a human-friendly version of a date value.</p>
<pre><code class="language-javascript">riba.formatters.date = function(value){
  return moment(value).format('MMM DD, YYYY')
}
</code></pre>
<p>Formatters are applied by piping them to binding declarations using <code>|</code> as a delimiter.</p>
<pre><code class="language-html">&lt;span rv-text=&quot;event.startDate | date&quot;&gt;&lt;/span&gt;
</code></pre>
</section><section class="my-4"><h3 id="two-way-formatters">Two-way formatters</h3><p>Two-way formatters are useful when you want to store a value in a particular format, such as a unix epoch time or a cent value, but still let the user input the value in a different format.</p>
<p>Instead of defining the formatter as a single function, you define it as an object containing <code>read</code> and <code>publish</code> functions. When a formatter is defined as a single function, riba assumes it to be in the read direction only. When defined as an object, riba uses it's <code>read</code> and <code>publish</code> functions to effectively serialize and de-serialize the value.</p>
<p>Using the cent value example from above, let's say we want to store a monetary value as cents but let the user input it in a dollar amount and automatically round to two decimal places when setting the value on the model. For this we can define a two-way <code>currency</code> formatter.</p>
<pre><code class="language-javascript">riba.formatters.currency = {
  read: function(value) {
    return (value / 100).toFixed(2)
  },
  publish: function(value) {
    return Math.round(parseFloat(value) * 100)
  }
}
</code></pre>
<p>You can then bind using this formatter with any one-way or two-way binder.</p>
<pre><code class="language-html">&lt;input rv-value=&quot;item.price | currency&quot;&gt;
</code></pre>
<p>Note that you can also chain bidirectional formatters with any other formatters, and in any order. They read from left to right, and publish from right to left, skipping any read-only formatters when publishing the value back to the model.</p>
</section><section class="my-4"><h3 id="formatter-arguments">Formatter arguments</h3><p>Formatters can accept any number of arguments in the form of keypaths or primitives. Keypath arguments get observed and will recompute the binding when any intermediary key changes. A primitive can be a string, number, boolean, null or undefined.</p>
<pre><code class="language-html">&lt;span&gt;{ alarm.time | time user.timezone 'hh:mm' }&lt;/span&gt;
</code></pre>
<p>The value of each argument in the binding declaration will be evaluated and passed into the formatter function as an additional argument.</p>
<pre><code class="language-javascript">riba.formatters.time = function(value, timezone, format) {
  return moment(value).tz(timezone).format(format)
}
</code></pre>
</section></section><section class="my-5"><h2 id="components">Components</h2><p>Components let you define reusable views that can be used within any of your templates. For some perspective on where components fit into your templates in relation to binders; binders define custom attributes, while components define custom elements.</p>
<p>A component object must define a <code>template</code> function, which returns the template for the component (this can be an HTML string or the actual element). It must also define an <code>initialize</code> function, which returns the scope object to bind the view with (this will likely be a controller / viewmodel / presenter).</p>
<pre><code class="language-javascript">rivets.components['todo-item'] = {
  // Return the template for the component.
  template: function() {
    return JST['todos/todo-item']
  },

  // Takes the original element and the data that was passed into the
  // component (either from rivets.init or the attributes on the component
  // element in the template).
  initialize: function(el, data) {
    return new ItemController({
      item: data.item
    })
  }
}
</code></pre>
<p>To use the component inside of a template, simply use an element with the same tag name as the component's key. All attributes on the element will get evaluated as keypaths before being passed into the component's <code>initialize</code> function.</p>
<pre><code class="language-html">&lt;todo-item item=&quot;myItem&quot;&gt;&lt;/todo-item&gt;
</code></pre>
<p>These keypaths will also be observed in both directions so that the component will update if the value changes from the outside and it will set the value if the component changes it from the inside.</p>
<p>Additionally, if you want certain attributes to be static instead of an observed keypath, you can list them out on the <code>static</code> property for your components.</p>
<pre><code class="language-javascript">rivets.components['todo-item'] = {
  static: ['list-style'],
  â€¦
}
</code></pre>
<pre><code class="language-html">&lt;todo-item item=&quot;myItem&quot; list-style=&quot;condensed&quot;&gt;&lt;/todo-item&gt;
</code></pre>
<p>Components can also be initialized on their own, outside of a template. This is useful when you want to insert a new view into the DOM yourself, such as the entry point to your entire application or the content of a modal. The API is similar to <code>rivets.bind</code>, except that instead of passing it an actual template / element, you just pass it the name of the component and the root element you want the component to render in.</p>
<pre><code>rivets.init('my-app', $('body'), {user: user})
</code></pre>
<pre><code>rivets.init('todo-item', $('#modal-content'), {item: myItem})
</code></pre>
</section><section class="my-5"><h2 id="adapters">Adapters</h2><p>riba is agnostic about the objects that it can subscribe to. This makes it very flexible as it can adapt to work with virtually any library or framework, but it also means that you need to tell riba <em>how</em> to subscribe to those objects. This is where adapters come in to play. This feature is driven by the observer pattern.</p>
<p>Each adapter is defined to a unique interface (a single character) which is used to separate the keys in a keypath. The interfaces used in a keypath determine which adapter to use for each intermediary key.</p>
<pre><code>user.address:city
</code></pre>
<p>The above keypath will use the <code>.</code> adapter to access the <code>address</code> key on the <code>user</code> object, and the <code>:</code> adapter to access the <code>city</code> key on the <code>address</code> object. If you can imagine for a second that <code>address</code> is just a normal property on the user object pointing to a Backbone model, but <code>city</code> is actually an attribute on that Backbone model, you can see how this kind of notation is actually very succint and expressive.</p>
<p>riba comes with a default <code>.</code> adapter based on custom property getter and setter</p>
<section class="my-4"><h3 id="the-built-in-adapter">The built-in adapter</h3><p>riba ships with a <code>.</code> adapter for subscribing to properties on plain JavaScript objects. The adapter is self-implemented using ES5 natives such as <code>Object.defineProperty</code>. In the future, this adapter will be implemented purely using <code>Object.observe</code> as soon as browser support permits.</p>
<p>If you need to support non-ES5 browsers (&lt; IE 9), you can replace this adapter to use polyfills or with a third-party library that has the browser support you need. If you're only targetting Chrome Canary, feel free to replace it with an <code>Object.observe</code> adapter now and enter data binding bliss.</p>
</section><section class="my-4"><h3 id="creating-an-adapter">Creating an adapter</h3><p>Adapters are defined on <code>riba.adapters</code> with the interface as the property name and the adapter object as the value. An adapter is just an object that responds to <code>observe</code>, <code>unobserve</code>, <code>get</code> and <code>set</code>.</p>
<p>The following <code>:</code> adapter works for Backbone.js models / Stapes.js modules.</p>
<pre><code class="language-javascript">riba.adapters[':'] = {
  observe: function(obj, keypath, callback) {
    obj.on('change:' + keypath, callback)
  },
  unobserve: function(obj, keypath, callback) {
    obj.off('change:' + keypath, callback)
  },
  get: function(obj, keypath) {
    return obj.get(keypath)
  },
  set: function(obj, keypath, value) {
    obj.set(keypath, value)
  }
}
</code></pre>
</section></section><section class="my-5"><h2 id="iteration-binding">Iteration binding</h2><section class="my-4"><h3 id="iterate">Iterate</h3><p>Use the <code>rv-each-[item]</code> binder to have Rivets.js automatically loop over items in an array and append bound instances of that element. Within that element you can bind to the iterated item as well as any contexts that are available in the parent view.</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li rv-each-todo=&quot;list.todos&quot;&gt;
    &lt;input type=&quot;checkbox&quot; rv-checked=&quot;todo.done&quot;&gt;
    &lt;span&gt;{ todo.summary }&lt;/span&gt;
  &lt;/li&gt;
&lt;ul&gt;
</code></pre>
</section><section class="my-4"><h3 id="iteration-index">Iteration index</h3><p>To access the index of the current iteration use the syntax <code>%item%</code>, Where <code>item</code> is the name of the model you provided in <code>rv-each-[item]</code>.  You can also access the index of the iteration by using the key <code>index</code> but using this will access only the current iterations index. Note that when nesting <code>rv-each</code>'s the parent index is still accessible within the scope via the model name.</p>
<pre><code class="language-html">&lt;ul&gt;
  &lt;li rv-each-user=&quot;app.users&quot;&gt;
    &lt;span&gt;User Index : { %user% }&lt;/span&gt;

    &lt;ul&gt;
        &lt;li rv-each-comment=&quot;user.comments&quot;&gt;
            &lt;span&gt;Comment Index : { %comment% }&lt;/span&gt;

            &lt;span&gt;User Index : { %user% }&lt;/span&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;ul&gt;
</code></pre>
</section></section></div></div></div></div></div></div>